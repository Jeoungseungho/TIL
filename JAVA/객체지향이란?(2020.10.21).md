# 객체 지향 프로그래밍이란?(2020.10.21)

## Object Oriented Programming

 > 객체 지향 프로그래밍은 문제를 여러개의 객체 단위로 나눠서 작업하는 방식을 말한다. 
 
 > 객체지향의 기본은 객체이며, 객체의 핵심은 기능을 제공하는 것이다. 실제로 객체를 정의할 때 사용하는 것은 객체가 제공해야 할 기능이며, 객체가 내부적으로 어떤 데이터를 가지고 있는지로는 정의되지 않는다. 이러한 기능들을 Operation이라고 부르고, 즉 객체는 Operation으로 정의가 된다.   
 
 객체 지향 프로그래밍이란 현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 어플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것이고 이를 추상화라고 한다.
 
 OOP로 작업을 하게 된다면 이미 작성한 코드에 대하여 재생산성이 높고, 자주 사용되는 로직을 라이브러리로 만들어 놓으면 계속해서 사용할 수 있다. 또한 라이브러리를 각종 예외상황에 맞게 만들어 놓는다면 개발자가 실수를 하더라도 그 에러를 컴파일 단계에서 잡아낼 수 있으므로 버그 발생이 줄어든다. 또한 내부적으로 어떻게 작동하는지 모르더라도 개발자는 라이브러리가 제공하는 기능들을 이용할 수 있기 떄문에 생산성이 높아지게 된다. 객체 단위로 코드가 나누어져 작성되기 떄문에 디버깅이 쉽고 유지보수에 용이해진다. 또한 데이터 모델링을 할 때 객체와 매핑하는 것이 수월해지기 떄문에 요구사항들을 보다 명백하게 파악하여 프로그래밍 할 수 있다. 
 
 단점으로는 객체 간의 정보 교환이 모두 메시지 교환을 통해서 일어나므로 실행 시스템에 많은 overhead가 일어나게 된다. 이 문제는 하드웨어의 발전으로 많은 부분 보완되었지만, 더 치명적인 문제는 객체가 상태를 가지기 때문에 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 가지게 되어서 어플리케이션 내부에서 버그를 발생 시킨다. 
 
## 객체지향 용어

### 1. 시그니처
-
객체지향으로 설계하기 위해서는 오퍼레이션의 사용법을 알아야하고 오퍼레이션의 샤용법은 다음 세가지로 구성된다. 

1. 기능 식별 이름
2. 파라미터 및 파라미터 타입
3. 기능 실행 결과 및 타입

이 세가지를 시그니처라고 부른다.

### 2. 인터페이스 
-
객체가 제공하는 모든 오퍼레이션의 집합을 객체의 인터페이스(Interface)라고 부른다. 

### 3. 메세지 
오퍼레이션의 실행을 요펑하는 것을 메세지 보낸다라고 표현하고, JAVA에서 메서드를 호출하는 것이 메세지를 보내는 과정에 해당한다. 

### 4. 책임 
 객체가 자신이 제공하는 기능으로 정의된다는 것은 객체마다 제공할 수 있는 기능에 대한 책임이 있다. 객체가 갖는 책임의 크기가 작을 수록 좋다. 
 즉, 객체가 제공하는 기능의 개수가 적은 것이 좋은 것이다. 한 객체에 많은 기능이 포함되면, 그 기능과 관련된 데이터들도 한 객체에 모두 포함된다. 이 경우에 객체에 정의된 많은 오퍼레이션들이 데이터를 공유하는 방식으로 프로그래밍 되는데, 이는 절차지향과 다를바 없으므로 책임의 크기는 작을수록 유연해 진다. 이것을  SRP(Single Responsibility Principle) : 단일 책임 원칙 이라고 한다. 
 
###  5. 의존성 
한 객체가 다른 객체를 이용한다는 것은, 실제 구현에서는 한 객체의 코드에서 다른 객체를 생성하거나 다른 객체의 메서드를 호출하는 것을 의미한다. 의존의 영향은 꼬리에 꼬리를 문 것처럼 전파된다. 이러다가 변경한 여파가 자기 자신까지 변화시킬 수 있는데, 이것을 순환 의존이라고 한다. 이것을 해결하는 것이 DIP(Dependency Inversion Principle) : 의존 역전 원칙이다. 


### 6. 캡슐화 
객체 지향은 기본적으로 캡슐화를 통해서 한 곳의 변화가 다른 곳에 미치는 영향을 최소화한다. 캡슐화란 객체 내부적으로 기능을 어떻게 구현하는지를 감추는 것이다. 내부 기능 구현이 변경되더라도, 그 기능을 사용하는 코드는 영향을 받지 않도록 해준다. 즉, 내부 구현 변경의 유연한을 주는 기법이 캡슐화이다.  

 
## 객체지향적 설계 원칙 (SOLID)
 
 1. SRP(Single Responsibility Principle) : 단일 책임 원칙 
 	 - 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유도 단 하나의 이유어야 한다.  이를 지키지 않을 떄, 한 책임의 구현 변경에 의해 다른 책임과 관련된 코드가 변경될 가능성이 높다. 


2.  OCP(Open-Closed Principle) : 개방-폐쇄 원칙 
	- 확장에는 열려있어야 하고 변경에는 닫혀 있어야 한다.  기능을 변경하거나 확장할 수 있으면서 그 기능을 사용하는 코드는 수정하지 않는다. 개방 폐쇄 원칙이 지켜지지 않을 떄의 현상으로는 instanceof 같은 타입 확인 연산자를 사용하거나 다운 캐스팅이 일어난다.

3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙 
	-  상위 타입의 객체를 하위 타입으로 치환해도 상위 타입을 사용하는 프로그램은 정상 작동해야 한다. 상속 관계로 묶일 수 없는 클래스들을 상속 관계로 설정했을 때 이 원칙에 어긋나게 된다. 

4. ISP(Inteface Segregation Principle) : 인터페이스 분리 원칙
	- 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다. 각 클라이언트가 필요로 하는 인터페이스들을 분리함으로, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생해도 영향을 받지 않아야 한다. 

5. DIP(Dependency Inversion Principle) : 의존 역전 원칙
	- 고수준의 모듈은 저수준 모듈의 구현에 의존해서는 안된다.  저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다. 즉, 저수준 모듈이 변경되더라도 고수준 모듈은 변경할 필요없는 것이다. 


## Dependency Injection 
생성자를 통해서 사용할 객체를 전달받도록 하는 것을 의존성 주입이라고 한다. 또는 설정 메소드 방식을 사용할 수 있다. 즉, setter 메소드를 통해 값을 설정하고, getter 메소드를 통해 값을 추출 하는 방식 또한 의존성 주입이라 할 수 있다. 
설정 메소드 방식은 객체를 생성한 뒤에 의존성 객체를 주입하게 되므로, 의존 객체를 설정하지 못한 상태에서 객체를 사용할 경우가 생길 수 있다. 이 때, NullPointerException이 발생할 수 있는 것이다. 
	
 
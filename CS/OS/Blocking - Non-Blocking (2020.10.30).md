# Blocking / Non-Blocking (2020.10.30)
![image](https://user-images.githubusercontent.com/44199159/97662313-0086b700-1aba-11eb-9618-3223524e53fd.png)
동기/동기는 **작업을 수행하는 주체**가 두 개 이상이어야 한다. 이 때 작업의 시간(시작, 종료 등등)을 서로 맞춘다면 이를 동기라고 부르고, 작업의 시간이 관계 없다면 이를  비동기라고 부른다. 반면 블로킹/논블로킹은 **작업의 대상**이 2개 이상이어야 다. 두 개념이 서로 보는 관점이 다르기 때문에 각각의 조합이 가능해진다. 

## 동기/비동기
동기 작업이란 작업을 수행하는 두 개 이상의 주체가 서로 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작할 때를 의미한다. 시작과 종료를 동시에 하거나, 하나의 작업이 끝나는 동시에 다른 주체가 작업을 시작하면 이는 동기 작업이라 볼 수 있다. 

비동기 작업은 두 주체가 서로의 시작, 종료 시간과는 상관 없이 별도의 수행 시작/종료시간을 가지고 있을 때를 뜻한다. 서로 다른 주체가 하는 작업이 자신의 작업 시작, 종료 시간과는 관계가 없을 때 비동기라고 부를 수 있다. 

## 블로킹 / 논블로킹
블로킹과 논블로킹은 다른 작업을 수행하는 주체를 어떻게 상대하는지가 중요하다. 자신의 작업을 하다가 다른 작업 주체가 하는 작업의 시작부터 끝까지 기다렸다가 다시 자신의 작업을 시작하면 블로킹이고, 다른 주체의 작업과 관계없이 자신의 작업을 계속한다면 이를 논블로킹이라고 할 수 있다. 

스레드 A가 어떤 작업을 하는 다른 대상을 호출하고, 그 대상이 가져온 결과물을 받아 다시 작업을 재개하고 있다. 예를 들어서 Java에서 JDBC를 이용하여 DB에 query를 날리고 결과를 받아오는 작업을 블로킹 작업이라고 부를 수 있다. 반대로 다른 주체에 작업을 요청하고 그 결과를 받을 때 까지 기다리지 않으며 자신의 작업을 한다면 이를 논블로킹이라 할 수 있다.

## 동기 + 블로킹
동기의 조건인 '두 개 이상의 작업을 시작시간, 종료시간이 같거나 시작과 동시에 종료할 것', 블로킹의 조건인 '다른 작업을 하는 동안 자신의 작업을 일시정지 할 것'을 만족하는 작업의 예시는 다음과 같다.

- JDBC를 이용하여 DB에 query를 날린다.
- 메서드에서 다른 메서드를 호출해서 결과값을 즉시 받아온다.

## 비동기 + 블로킹

비동기의 조건인 '다른 작업과 시작, 종료시간을 맞추지 않는다.'와 블로킹의 조건인 '다른 작업의 주체가 작업하는 동안 기다릴 것'을 만족해야 한다. 비동기, 블로킹의 조합은 결국 다른 작업이 끝날 때를 기다려야하기 때문에 동기, 블로킹과 비슷한 작업 효율이 나온다. 즉 그리 좋은 효율이 아니다. 개발자가 유도해서 이 상황을 만드는 것보다 비동기, 논블로킹 작업을 실행했지만 자기도 모르게 블로킹 작업을 실행했을 때 이런 결과가 나온다. 

- 비동기, 논블로킹 작업을 호출하고 자신의 작업을 하던 도중 호출한 작업의 결과 값을 조회하려고 했을 때(블로킹 메소드 실행)


## 동기 + 논블로킹
동기의 조건인 '두 개 이상의 작업의 시작 시간, 종료시간이 같거나 시작과 동시에 종료할것', 논블로킹의 조건인 '다른 작업의 주체가 직업하는 동안 기다리지 말 것' 을 만족하는 동기+ 논블로킹 조합도 비동기+ 블로킹 조합처럼 작업 효율이 좋지 않은 편이다. 논블로킹으로 자신의 작업을 계속하고 있지만 다른 작업과의 동기를 위해 계속해서 다른 작업이 끝났는지 조회한다. 

- polling
  
## 비동기 + 논블로킹
'다른 작업과 시작, 종료시간을 맞추지 말 것', '다른 작업의 주체가 작업하는 동안 기다리지 말 것'을 만족하는 비동기, 논블로킹 조합은 자원이 충분하다면 효율이 좋은 조합이다. 자신의 작업이 멈추지 않고, 다른 주체가 하는 작업의 결과가 나왔을 때 콜백을 설정하기도 한다. 다른 주체에게 작업을 맡겨놓고 자신이 하던 일을 계속할 수 있기 때문에 해야 할 작업이 대규모이고, 동기가 필요하지 않을 때 효과적이다. 

- 대규모 사용자에게 푸시메세지 전송
- 다양한 외부 API를 한번에 호출  





























